# CLAUDE.md - AI Assistant Guide for Bible Repository

> This document provides context and guidelines for AI assistants working with this codebase.

## Project Overview

**Repository:** Bible
**Type:** Cross-platform mobile application (Web + iOS + Android)
**Tech Stack:** Web app with Capacitor wrapper
**Development Model:** AI-driven development with human oversight
**Project Status:** Non-profit / Open Source

### Licensing & Dependencies

This is a **non-profit project**. All dependencies must be:
- Open source with permissive licenses (MIT, Apache 2.0, BSD, ISC)
- Free for non-commercial use
- No proprietary or paid-tier-only features

When selecting libraries or tools, AI must verify license compatibility.

## Development Philosophy

This project follows an **AI-assisted development model**:

| Role | Responsibility |
|------|----------------|
| **Human Developer** | Infrastructure decisions, architecture, code review, approval |
| **AI Assistant** | Implementation details, writing code, following specifications |

### Key Principles

1. **AI writes all code** - Implementation is handled entirely by AI
2. **Human reviews everything** - All code must be reviewed and approved before merging
3. **Human decides architecture** - Infrastructure, tech choices, and design patterns are human decisions
4. **AI executes the vision** - AI implements according to specifications provided

## Tech Stack

### Core Technologies

- **Framework:** [Next.js](https://nextjs.org/) with React
- **Language:** TypeScript (strict mode)
- **Styling:** [Tailwind CSS](https://tailwindcss.com/)
- **UI Components:** [shadcn/ui](https://ui.shadcn.com/) (copy-paste components, Radix primitives, MIT license)
- **State Management:** React Context (built-in, for theme/auth/settings)
- **Data Persistence:** IndexedDB via Dexie.js (for offline-first data storage)
- **Sync Engine:** Custom sync service with conflict resolution
- **Mobile Wrapper:** [Capacitor](https://capacitorjs.com/) for iOS and Android
- **Offline Strategy:** Offline-first architecture (app works without network)

### Design-to-Code Workflow

UI components are generated via **Figma Make** and similar Figma-to-code tools. AI must:
- Follow Tailwind CSS conventions for all styling
- Use utility-first classes as generated by Figma tools
- Maintain consistency with Figma-exported component patterns
- Not override or restructure Figma-generated code without architect approval

### Project Structure

```
Bible/
├── CLAUDE.md              # AI assistant guidelines (this file)
├── README.md              # Project documentation
├── package.json           # Dependencies and scripts
├── next.config.mjs        # Next.js configuration
├── postcss.config.mjs     # PostCSS configuration
├── tsconfig.json          # TypeScript configuration
├── components.json        # shadcn/ui configuration
├── app/                   # Next.js App Router
│   ├── layout.tsx         # Root layout with providers
│   ├── page.tsx           # Home page (book/chapter/reader views)
│   └── globals.css        # Global styles
├── functions/             # Firebase Cloud Functions
│   ├── src/index.ts       # Search API endpoint (OpenAI integration)
│   ├── package.json       # Functions dependencies
│   └── tsconfig.json      # Functions TypeScript config
├── components/            # React components
│   ├── ui/                # shadcn/ui primitives
│   ├── ai-search.tsx      # AI-powered verse search overlay
│   ├── book-list.tsx      # Book selection grid
│   ├── chapter-grid.tsx   # Chapter selection grid
│   ├── verse-reader.tsx   # Verse display with navigation
│   ├── settings-sheet.tsx # Settings panel
│   ├── timeline-sheet.tsx # Reading history timeline
│   ├── theme-provider.tsx # Theme context (light/dark/system)
│   ├── language-provider.tsx    # Language/i18n context
│   ├── settings-provider.tsx    # Settings context (font, version)
│   └── reading-history-provider.tsx # Reading analytics context
├── lib/                   # Shared utilities and helpers
│   ├── bible-data.ts      # Book metadata (66 books)
│   ├── bible-loader.ts    # Verse loading with caching
│   ├── bible-versions.ts  # Bible version definitions
│   ├── translations.ts    # i18n (English, Polish, Norwegian)
│   ├── reading-history.ts # Reading analytics types/utilities
│   └── utils.ts           # Tailwind utilities
├── hooks/                 # Custom React hooks
│   └── use-verses.ts      # Async verse loading hook
├── public/                # Static assets
│   └── bibles/            # Bible JSON files (KJV, ASV, WEB, BG, UBG)
├── ios/                   # iOS native project (Capacitor-generated)
├── android/               # Android native project (Capacitor-generated)
└── __tests__/             # Test files
```

## Development Workflow

### AI-Human Collaboration Flow

```
1. Human defines requirement/feature
         ↓
2. AI proposes implementation approach (if complex)
         ↓
3. Human approves or adjusts approach
         ↓
4. AI implements the code
         ↓
5. Human reviews the code
         ↓
6. AI addresses feedback if needed
         ↓
7. Human approves and merges
```

### Git Branching Strategy

- **Main branch:** Production-ready, human-approved code only
- **Feature branches:** `feature/<description>` or `claude/<description>-<session-id>`
- **Bugfix branches:** `fix/<description>`

### Bug Workflow

For issues labeled as `bug` in the repository:

1. AI checks for bugs using `gh issue list --label bug`
2. AI creates a fix branch: `fix/<issue-description>`
3. AI implements the fix
4. AI creates a PR for human review
5. Human reviews and merges

### Commit Message Conventions

Follow conventional commits:
- `feat:` New features
- `fix:` Bug fixes
- `docs:` Documentation changes
- `refactor:` Code refactoring
- `test:` Test additions/modifications
- `chore:` Maintenance tasks
- `style:` Formatting, no code change
- `perf:` Performance improvements

Example: `feat(auth): add biometric login for mobile`

## Code Style and Conventions

### General Principles

1. **Readability over cleverness** - Write code humans can easily review
2. **Explicit over implicit** - Make intentions clear
3. **Small, focused functions** - Easy to understand and test
4. **Consistent patterns** - Follow established patterns in the codebase

### Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Files (components) | PascalCase | `UserProfile.tsx` |
| Files (utilities) | kebab-case | `user-service.ts` |
| Components | PascalCase | `UserProfile` |
| Functions | camelCase | `getUserById()` |
| Constants | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| Types/Interfaces | PascalCase | `UserProfile` |
| Tailwind classes | utility-first | `flex items-center gap-4` |
| Custom CSS classes | kebab-case | `custom-scrollbar` |

### Tailwind CSS Guidelines

- **Utility-first approach** - Use Tailwind utilities, avoid custom CSS when possible
- **Consistent ordering** - Follow logical grouping: layout → spacing → sizing → typography → colors → effects
- **Responsive design** - Use Tailwind breakpoints (`sm:`, `md:`, `lg:`, `xl:`, `2xl:`)
- **Dark mode** - Use `dark:` variant for dark mode styles when implemented
- **Component extraction** - Extract repeated utility patterns into components, not `@apply`
- **Figma alignment** - Match Tailwind classes to Figma design tokens

### TypeScript Guidelines

- **No `any`** - Use proper types or `unknown` with type guards
- **Interfaces for objects** - Define clear contracts
- **Strict mode enabled** - Catch errors at compile time
- **Explicit return types** - For public functions

### Mobile-Specific Guidelines

- **Responsive design** - Support various screen sizes
- **Touch-friendly** - Minimum 44x44px touch targets
- **Offline-first** - App must work fully offline; sync when connected
- **Platform awareness** - Use Capacitor's platform detection when needed

## Offline Support & Sync Architecture

### Core Principles

The app follows an **offline-first architecture**:

1. **Local-first** - All data is stored locally and available offline
2. **Background sync** - Changes sync to server when connectivity is available
3. **Conflict resolution** - Automatic handling of conflicting changes
4. **Transparent to user** - Sync happens seamlessly without user intervention

### Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                        CLIENT (App)                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │   UI Layer   │───▶│  Sync Engine │◀──▶│  IndexedDB   │       │
│  │   (React)    │    │              │    │  (Dexie.js)  │       │
│  └──────────────┘    └──────┬───────┘    └──────────────┘       │
│                             │                                    │
└─────────────────────────────┼────────────────────────────────────┘
                              │ (when online)
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        SERVER (API)                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │   REST API   │───▶│  Sync Logic  │◀──▶│   Database   │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
└─────────────────────────────────────────────────────────────────┘
```

### Local Storage Strategy

#### IndexedDB (via Dexie.js)

All user data is stored in IndexedDB for offline access:

| Store | Purpose | Sync Priority |
|-------|---------|---------------|
| `bibleContent` | Bible text (books, chapters, verses) | Initial download, rarely updated |
| `userHighlights` | Verse highlights and colors | High - sync immediately |
| `userBookmarks` | Bookmarked verses | High - sync immediately |
| `userNotes` | Personal notes on verses | High - sync immediately |
| `readingHistory` | Chapter read timestamps for timeline | Medium - sync periodically |
| `readingProgress` | Last read position | Medium - sync periodically |
| `settings` | User preferences (theme, font size, language) | Low - sync on change |
| `syncQueue` | Pending changes to sync | Internal use |
| `syncMetadata` | Last sync timestamps, versions | Internal use |

#### Reading History Data Structure

The `readingHistory` store tracks individual verses read for the timeline feature. Designed for Firebase Firestore compatibility:

```typescript
interface ReadingRecord {
  id: string;           // UUID v4 for sync conflict resolution
  bookId: string;       // e.g., "gen", "mat"
  chapter: number;      // Chapter number
  verses: number[];     // Array of verse numbers read (1-indexed)
  versionId: string;    // Bible version used
  timestamp: string;    // ISO 8601: "2026-01-26T10:30:00.000Z"
}
```

- **UUID IDs** prevent conflicts when syncing from multiple devices
- **ISO 8601 timestamps** convert directly to Firestore Timestamp
- **Verse-level tracking** with auto-save on selection
- **Max 1000 records** stored to prevent excessive storage usage

#### Data Schema Pattern

```typescript
interface SyncableEntity {
  id: string;                    // UUID, generated client-side
  createdAt: number;             // Unix timestamp
  updatedAt: number;             // Unix timestamp
  deletedAt: number | null;      // Soft delete timestamp
  syncStatus: 'pending' | 'synced' | 'conflict';
  version: number;               // Incremented on each change
  deviceId: string;              // Origin device identifier
}
```

### Sync Engine

#### Sync Process

```
1. App starts / comes online
         ↓
2. Check network connectivity
         ↓
3. Pull: Fetch server changes since last sync
         ↓
4. Merge: Apply server changes to local DB
         ↓
5. Resolve: Handle any conflicts
         ↓
6. Push: Send local pending changes to server
         ↓
7. Update sync metadata
```

#### Conflict Resolution Strategy

When the same entity is modified on multiple devices:

| Scenario | Resolution |
|----------|------------|
| Same field, different values | **Last-write-wins** based on `updatedAt` timestamp |
| Different fields modified | **Merge** both changes |
| One deleted, one modified | **Keep modification**, mark as undeleted |
| Both deleted | **Keep deleted** |

For user data (highlights, bookmarks, notes):
- Use **last-write-wins** as default strategy
- Store conflict history for potential manual resolution (future feature)

#### Sync Queue Management

```typescript
interface SyncQueueItem {
  id: string;
  entityType: 'highlight' | 'bookmark' | 'note' | 'progress' | 'setting';
  entityId: string;
  operation: 'create' | 'update' | 'delete';
  payload: Record<string, unknown>;
  timestamp: number;
  retryCount: number;
  maxRetries: number;  // Default: 5
}
```

### Network Handling

#### Connectivity Detection

Use Capacitor's Network plugin for reliable detection:

```typescript
import { Network } from '@capacitor/network';

// Listen for network changes
Network.addListener('networkStatusChange', (status) => {
  if (status.connected) {
    syncEngine.startSync();
  }
});
```

#### Retry Strategy

For failed sync operations:

| Retry | Delay | Notes |
|-------|-------|-------|
| 1 | 1 second | Immediate retry |
| 2 | 5 seconds | Short delay |
| 3 | 30 seconds | Medium delay |
| 4 | 2 minutes | Longer delay |
| 5 | 10 minutes | Final attempt |
| Failed | - | Move to dead letter queue, notify user |

### Implementation Guidelines

#### Service Structure

```
src/
├── services/
│   ├── sync/
│   │   ├── sync-engine.ts      # Main sync orchestrator
│   │   ├── sync-queue.ts       # Queue management
│   │   ├── conflict-resolver.ts # Conflict resolution logic
│   │   ├── network-monitor.ts  # Connectivity handling
│   │   └── index.ts
│   ├── db/
│   │   ├── database.ts         # Dexie.js configuration
│   │   ├── repositories/       # Data access layer
│   │   │   ├── highlights.ts
│   │   │   ├── bookmarks.ts
│   │   │   ├── notes.ts
│   │   │   └── settings.ts
│   │   └── index.ts
│   └── api/
│       ├── sync-api.ts         # Server sync endpoints
│       └── index.ts
├── hooks/
│   ├── useOfflineStatus.ts     # Network status hook
│   ├── useSyncStatus.ts        # Sync state hook
│   └── useOfflineData.ts       # Data access with offline support
```

#### React Context Providers

The app uses multiple React Context providers for state management:

```
ThemeProvider (next-themes)
└── LanguageProvider (language, translations)
    └── SettingsProvider (fontSize, versionId)
        └── ReadingHistoryProvider (reading analytics)
            └── App
```

| Provider | Hook | Purpose |
|----------|------|---------|
| `ThemeProvider` | `useTheme()` | Light/dark/system theme |
| `LanguageProvider` | `useLanguage()` | UI language, translations |
| `SettingsProvider` | `useSettings()` | Font size, Bible version |
| `ReadingHistoryProvider` | `useReadingHistory()` | Reading analytics, timeline |

#### Future: React Context for Sync State

```typescript
interface SyncContextValue {
  isOnline: boolean;
  isSyncing: boolean;
  lastSyncTime: Date | null;
  pendingChanges: number;
  syncError: Error | null;
  triggerSync: () => Promise<void>;
}
```

#### UI Indicators

Display sync status to users:
- **Online + Synced** - Green checkmark or no indicator
- **Online + Syncing** - Subtle spinner
- **Online + Pending** - Cloud with arrow
- **Offline** - Cloud with slash, "Changes saved locally"
- **Sync Error** - Warning icon with retry option

### Bible Content Strategy

Bible text is handled differently from user data:

1. **Initial Download** - Full Bible downloaded on first launch
2. **Bundled Fallback** - Core content bundled with app binary
3. **Incremental Updates** - Only fetch when new translations available
4. **Version Checking** - Compare content version before downloading

### Security Considerations

- **Encrypt sensitive data** at rest in IndexedDB (future consideration)
- **Authenticate sync requests** with user token
- **Validate data integrity** with checksums
- **Sanitize inputs** before storage and sync

### Testing Offline Functionality

#### Manual Testing Checklist

- [ ] App loads without network connection
- [ ] All read operations work offline
- [ ] Write operations queue properly offline
- [ ] Sync triggers when connection restored
- [ ] Conflicts resolve correctly
- [ ] UI reflects current sync state
- [ ] No data loss during sync failures

#### Automated Testing

- Mock network status in tests
- Test sync queue operations
- Test conflict resolution scenarios
- Test retry logic with failures

## Commands Reference

### Development
```bash
# Install dependencies
npm install

# Run web development server
npm run dev

# Build for production
npm run build
```

### Capacitor Commands
```bash
# Add iOS platform
npx cap add ios

# Add Android platform
npx cap add android

# Sync web build to native projects
npx cap sync

# Open iOS project in Xcode
npx cap open ios

# Open Android project in Android Studio
npx cap open android

# Run on device/emulator
npx cap run ios
npx cap run android
```

### Testing
```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage
```

### Linting
```bash
# Run linter
npm run lint

# Fix linting issues
npm run lint:fix
```

## AI Assistant Guidelines

### Before Starting Any Task

1. **Gather requirements** - Ensure you have all information needed before starting
2. **Research and evaluate scope** - Use web search, docs, and codebase exploration to understand the full scope
3. **Ask clarifying questions** - If requirements are ambiguous, ask before implementing
4. **Read existing code** - Understand current patterns and structure
5. **Check CLAUDE.md** - Follow documented conventions

### When Implementing Features

1. **Follow specifications exactly** - Don't add unrequested features
2. **Match existing patterns** - Consistency is key for review
3. **Keep changes minimal** - Easier to review smaller changes
4. **Comment complex logic** - Help the reviewer understand intent
5. **Consider mobile context** - Remember this runs on phones

### Code Quality Checklist

Before submitting code for review:
- [ ] Follows project conventions and patterns
- [ ] No hardcoded secrets or credentials
- [ ] Proper error handling implemented
- [ ] Works on web, iOS, and Android
- [ ] Responsive design considered
- [ ] TypeScript strict mode passes
- [ ] Tests added for new functionality
- [ ] Works offline (data persisted locally)
- [ ] Sync queue updated for data changes

### Things AI Must NOT Do

- Make architectural decisions without human approval
- Add dependencies without explicit permission
- Change project structure without approval
- Skip error handling
- Use `any` type in TypeScript
- Ignore mobile/cross-platform considerations
- Over-engineer beyond requirements

### Things AI Should Always Do

- Write clean, reviewable code
- Follow existing patterns exactly
- Ask for clarification when requirements are ambiguous
- Consider edge cases and error states
- Test on all platforms when relevant
- Document non-obvious implementation choices

## Architecture Decisions

*Documented by the human architect as decisions are made.*

### Decision Log

| Date | Decision | Rationale | Decided By |
|------|----------|-----------|------------|
| 2026-01-26 | AI-driven development model | Leverage AI for implementation while maintaining human oversight | Architect |
| 2026-01-26 | Non-profit, open source only | All dependencies must have permissive OSS licenses | Architect |
| 2026-01-26 | Capacitor for mobile | Single codebase for web, iOS, Android (MIT license) | Architect |
| 2026-01-26 | Next.js with React | Modern React framework with SSR/SSG capabilities (MIT license) | Architect |
| 2026-01-26 | Tailwind CSS | Best Figma-to-code compatibility, utility-first approach (MIT license) | Architect |
| 2026-01-26 | Figma Make for UI | Design-to-code workflow, generates Tailwind-compatible React | Architect |
| 2026-01-26 | shadcn/ui | Best Figma ecosystem, copy-paste model, Radix primitives (MIT license) | Architect |
| 2026-01-26 | React Context | Simple global state (theme, auth, settings), no extra dependencies | Architect |
| 2026-01-26 | MVP scope: navigation only | Simple Bible navigation, defer highlights/AI search to future | Architect |
| 2026-01-26 | Offline-first architecture | App must work fully offline; sync when connected | Architect |
| 2026-01-26 | IndexedDB via Dexie.js | Robust local storage for offline data (Apache 2.0 license) | Architect |
| 2026-01-26 | Last-write-wins conflict resolution | Simple, predictable conflict handling for user data | Architect |
| 2026-01-26 | Background sync with retry | Automatic sync with exponential backoff on failure | Architect |
| 2026-01-26 | Reading history with timestamps | Track chapter reads for analytics and future Firebase sync | Architect |
| 2026-01-26 | UUID + ISO 8601 for reading records | Firebase-compatible data structure, conflict-free sync | Architect |
| 2026-01-28 | AI-powered verse search | Semantic search using OpenAI API, server-side API key | Architect |

## MVP Scope

### Included (MVP)
- Bible navigation (books, chapters, verses)
- Reading view
- Theme support (light/dark)
- Basic settings
- Multi-language support (English, Polish, Norwegian)
- Multiple Bible versions (KJV, ASV, WEB, BG, UBG)
- **Reading history timeline** (tracks chapters read with timestamps)
- **Offline support** (app works without network)
- **Local data persistence** (IndexedDB via Dexie.js)
- **Background sync** (when connected)
- **AI-powered verse search** (semantic search using OpenAI)

### Deferred (Future Features)
- Verse highlights
- Bookmarks
- User accounts
- Firebase sync for reading history
- End-to-end encryption for synced data
- Manual conflict resolution UI

## Environment Setup

### Prerequisites

- Node.js (LTS version)
- npm or yarn
- For iOS: macOS with Xcode
- For Android: Android Studio with SDK

### Environment Variables

The application requires the following environment variables:

| Variable | Purpose | Required |
|----------|---------|----------|
| `OPENAI_API_KEY` | OpenAI API key for AI-powered verse search | Yes (for AI search) |

**Local Development:** Create a `.env.local` file in the project root:
```
OPENAI_API_KEY=sk-your-key-here
```

**Production:** Environment variables are configured via GitHub Actions secrets and injected during deployment.

### Local Development Setup

```bash
# Clone repository
git clone <repository-url>
cd Bible

# Install dependencies
npm install

# Create .env.local with required variables (see above)

# Start development server
npm run dev
```

### Mobile Development Setup

```bash
# Build web app
npm run build

# Sync to native projects
npx cap sync

# For iOS (requires macOS)
npx cap open ios

# For Android
npx cap open android
```

## Project Dependencies

### Core Dependencies

| Package | Purpose | Status |
|---------|---------|--------|
| `next` | React framework | Decided |
| `react`, `react-dom` | UI library | Decided |
| `typescript` | Type safety | Decided |
| `tailwindcss` | Styling | Decided |
| `@capacitor/core` | Mobile wrapper | Decided |
| `@capacitor/ios` | iOS platform | Decided |
| `@capacitor/android` | Android platform | Decided |

### Additional Dependencies

| Package | Purpose | Status |
|---------|---------|--------|
| `@radix-ui/*` | Accessible primitives (via shadcn/ui) | Decided |
| `class-variance-authority` | Component variants (shadcn/ui) | Decided |
| `clsx`, `tailwind-merge` | Class utilities (shadcn/ui) | Decided |
| `dexie` | IndexedDB wrapper for offline storage (Apache 2.0) | Decided |
| `@capacitor/network` | Network status detection (MIT) | Decided |

### Deferred Decisions

*To be decided when needed:*

| Category | Options | Notes |
|----------|---------|-------|
| Data Fetching | TanStack Query (MIT), SWR (MIT) | For server API calls (optional) |
| Form Handling | React Hook Form (MIT) | When complex forms are needed |
| Backend/Auth | TBD | When user accounts are implemented |
| Encryption | crypto-js (MIT), Web Crypto API | For E2E encrypted sync (future) |

## Troubleshooting

### Common Issues

*To be documented as issues are encountered.*

### Capacitor-Specific Issues

- **Sync issues:** Run `npx cap sync` after any web build
- **Plugin not working:** Ensure native project is rebuilt after adding plugins
- **iOS build fails:** Check Xcode signing and provisioning profiles
- **Android build fails:** Verify SDK versions and Gradle sync

## Resources

### Framework & Libraries
- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://react.dev/)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)

### Mobile (Capacitor)
- [Capacitor Documentation](https://capacitorjs.com/docs)
- [Capacitor Plugins](https://capacitorjs.com/docs/plugins)
- [Capacitor + Next.js Guide](https://capacitorjs.com/docs/guides/nextjs)
- [iOS Development Guide](https://capacitorjs.com/docs/ios)
- [Android Development Guide](https://capacitorjs.com/docs/android)

### Design-to-Code
- [Figma Make](https://www.figma.com/make/)
- [Builder.io Visual Copilot](https://www.builder.io/)

### UI Components (shadcn/ui)
- [shadcn/ui Documentation](https://ui.shadcn.com/)
- [shadcn/ui Components](https://ui.shadcn.com/docs/components)
- [shadcn/ui Figma Resources](https://ui.shadcn.com/docs/figma)
- [Radix UI Primitives](https://www.radix-ui.com/) (underlying library)

### Offline & Sync
- [Dexie.js Documentation](https://dexie.org/docs/)
- [Dexie.js Sync Protocol](https://dexie.org/docs/Syncable/Dexie.Syncable.js)
- [Capacitor Network Plugin](https://capacitorjs.com/docs/apis/network)
- [IndexedDB API (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [Offline-First Web Apps](https://web.dev/offline-cookbook/)

---

*Last updated: 2026-01-28*
*Reading history/timeline feature added: 2026-01-26*
*AI-powered verse search added: 2026-01-28*
